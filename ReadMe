---------------------------------------------------------------LikeOptional----------------------------------------
/*
    Реализуйте generic-класс Pair, похожий на Optional, но содержащий пару элементов разных типов и не запрещающий 
    элементам принимать значение null.

    Реализуйте методы getFirst(), getSecond(), equals() и hashCode(), а также статический фабричный метод of(). 
    Конструктор должен быть закрытым (private).

    С корректно реализованным классом Pair должен компилироваться и успешно работать следующий код:

    Pair<Integer, String> pair = Pair.of(1, "hello");

    Integer i = pair.getFirst(); // 1

    String s = pair.getSecond(); // "hello"

    Pair<Integer, String> pair2 = Pair.of(1, "hello");

    boolean mustBeTrue = pair.equals(pair2); // true!

    boolean mustAlsoBeTrue = pair.hashCode() == pair2.hashCode(); // true!

 */
--------------------------------------------------------------MessageSortAndPrint---------------------------------------
 
/*      Напишите программу, читающую из System.in текст в кодировке UTF-8, подсчитывающую в нем частоту появления слов,
        и в конце выводящую 10 наиболее часто встречающихся слов.

        Словом будем считать любую непрерывную последовательность символов, состоящую только из букв и цифр. Например,
        в строке "Мама мыла раму 33 раза!" ровно пять слов: "Мама", "мыла", "раму", "33" и "раза".

        Подсчет слов должен выполняться без учета регистра, т.е. "МАМА", "мама" и "Мама" — это одно и то же слово.
        Выводите слова в нижнем регистре.

        Если в тексте меньше 10 уникальных слов, то выводите сколько есть.

        Если в тексте некоторые слова имеют одинаковую частоту, т.е. их нельзя однозначно упорядочить только по частоте,
         то дополнительно упорядочите слова с одинаковой частотой в лексикографическом порядке.
    */
