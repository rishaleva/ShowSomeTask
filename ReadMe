----------------------------------------------------------LikeOptional-------------------------------------------------
/*
    Реализуйте generic-класс Pair, похожий на Optional, но содержащий пару элементов разных типов и не запрещающий 
    элементам принимать значение null.

    Реализуйте методы getFirst(), getSecond(), equals() и hashCode(), а также статический фабричный метод of(). 
    Конструктор должен быть закрытым (private).

    С корректно реализованным классом Pair должен компилироваться и успешно работать следующий код:

    Pair<Integer, String> pair = Pair.of(1, "hello");

    Integer i = pair.getFirst(); // 1

    String s = pair.getSecond(); // "hello"

    Pair<Integer, String> pair2 = Pair.of(1, "hello");

    boolean mustBeTrue = pair.equals(pair2); // true!

    boolean mustAlsoBeTrue = pair.hashCode() == pair2.hashCode(); // true!

 */
--------------------------------------------------------MessageSortAndPrint--------------------------------------------
/*      Напишите программу, читающую из System.in текст в кодировке UTF-8, подсчитывающую в нем частоту появления слов,
        и в конце выводящую 10 наиболее часто встречающихся слов.

        Словом будем считать любую непрерывную последовательность символов, состоящую только из букв и цифр. Например,
        в строке "Мама мыла раму 33 раза!" ровно пять слов: "Мама", "мыла", "раму", "33" и "раза".

        Подсчет слов должен выполняться без учета регистра, т.е. "МАМА", "мама" и "Мама" — это одно и то же слово.
        Выводите слова в нижнем регистре.

        Если в тексте меньше 10 уникальных слов, то выводите сколько есть.

        Если в тексте некоторые слова имеют одинаковую частоту, т.е. их нельзя однозначно упорядочить только по частоте,
         то дополнительно упорядочите слова с одинаковой частотой в лексикографическом порядке.
    */

Создайте в статичном публичном методе logging логгер с именем com.javamentor.logging.Test, залогируйте им два сообщения:
 первое "Все хорошо" с уровнем INFO и второе "Произошла ошибка" с уровнем WARNING.


--------------------------------------------------------HowLog----------------------------------------------------------
/*
    Создайте в статичном публичном методе logging логгер с именем com.javamentor.logging.Test, залогируйте им два
    сообщения: первое "Все хорошо" с уровнем INFO и второе "Произошла ошибка" с уровнем WARNING.
     */

-------------------------------------------------------TextByRole-------------------------------------------------------
/*
     Вам дан список ролей и сценарий пьесы в виде массива строчек. Каждая строчка сценария пьесы дана в следующем виде:

     Роль: текст

     Текст может содержать любые символы.

     Задание:

     Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать результат в виде
     готового текста (см. пример). Каждая группа распечатывается в следующем виде:

     Роль:
     i) текст
     j) текст2
     ...
     ==перевод строки==

     i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы следует в соответствии с
     порядком ролей. Переводы строк между группами обязательны, переводы строк в конце текста не учитываются.

     Заметим, что вам предстоит обработка огромной пьесы в 50 000 строк для 10 ролей – соответственно, неправильная
     сборка результирующей строчки может выйти за ограничение по времени.

     Обратите внимание еще на несколько нюансов:

     имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
     название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
     роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
     в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
     будьте внимательны, не добавляйте лишних пробелов в конце строк.
     Пример ввода 1:
     roles:
     Городничий
     Аммос Федорович
     Артемий Филиппович
     Лука Лукич
     textLines:
     Городничий: Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
     Аммос Федорович: Как ревизор?
     Артемий Филиппович: Как ревизор?
     Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
     Аммос Федорович: Вот те на!
     Артемий Филиппович: Вот не было заботы, так подай!
     Лука Лукич: Господи боже! еще и с секретным предписаньем!
     Пример вывода 1:
     Городничий:
     1) Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
     4) Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.

     Аммос Федорович:
     2) Как ревизор?
     5) Вот те на!

     Артемий Филиппович:
     3) Как ревизор?
     6) Вот не было заботы, так подай!

     Лука Лукич:
     7) Господи боже! еще и с секретным предписаньем!

     Требования:
     1. Метод должен быть публичным.
     2. Метод должен принимать на вход два массива строк.
     3. Метод должен возвращать строку.
     4. Результативная строка должна соответствовать уcловию.
     5. Необходимо использовать StringBuilder
     */

-------------------------------------------------------SalesMap---------------------------------------------------------
/*
     Магазину нужно сохранять информацию о продажах для каждого сотрудника. Напишите метод Map getSalesMap(Reader reader)
      который принимает Reader содержащий строки вида:

     Алексей 3000

     Дмитрий 9000

     Антон 3000

     Алексей 7000

     Антон 8000

     Метод должен получить все строки из Readera и заполнить и вернуть карту где ключом будет имя сотрудника, а
     значением сумма всех его продаж.

     Пример ввода:

     Алексей 3000

     Дмитрий 9000

     Антон 3000

     Алексей 7000

     Антон 8000

     Пример вывода:

     {Алексей=[10000], Дмитрий=[9000], Антон=[11000]}

     Требования:

     1. Должен быть метод public static Map<String, Long> getSalesMap(Reader reader)

     2. Работа метода getSalesMap должна удовлетворять условию
     */